# -*- coding: utf-8 -*-
"""Introduction Time Series Method.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1H64QbTwjS8LdQiM6cIdPWxx6ZcOIQWOY

**1. Introduction to Time Series Forecasting**

Jawab :

Deret waktu adalah urutan di mana metrik dicatat selama interval waktu yang teratur.

Bergantung pada frekuensi, deret waktu dapat berupa tahunan (mis: anggaran tahunan), triwulanan (mis: pengeluaran), bulanan (mis: lalu lintas udara), mingguan (mis: jumlah penjualan), harian (mis: cuaca), setiap jam (mis: harga saham), menit (mis: panggilan masuk di canter panggilan) dan bahkan detik (mis: lalu lintas web).

Kami telah melihat langkah-langkah yang terlibat dalam posting sebelumnya tentang Analisis Time Series. Jika Anda belum membacanya, saya sangat menganjurkan Anda untuk membacanya.

Peramalan adalah langkah berikutnya di mana Anda ingin memprediksi nilai masa depan yang akan diambil oleh rangkaian tersebut.

Tapi kenapa ramalan?

Karena, meramalkan rangkaian waktu (seperti permintaan dan penjualan) seringkali memiliki nilai komersial yang luar biasa.

Di sebagian besar perusahaan manufaktur, ini mendorong perencanaan bisnis, pengadaan, dan kegiatan produksi yang mendasar. Setiap kesalahan dalam prakiraan akan beriak di seluruh rantai pasokan atau konteks bisnis apa pun dalam hal ini. Jadi, penting untuk mendapatkan perkiraan yang akurat untuk menghemat biaya dan sangat penting untuk kesuksesan.

Tidak hanya di bidang manufaktur, teknik dan konsep di balik peramalan deret waktu dapat diterapkan dalam bisnis apa pun.

Sekarang peramalan deret waktu dapat secara luas dibagi menjadi dua jenis.

Jika Anda hanya menggunakan nilai deret waktu sebelumnya untuk memprediksi nilai masa depan, ini disebut Peramalan Deret Waktu Univariat.

Dan jika Anda menggunakan prediktor selain seri (alias variabel eksogen) untuk meramalkan itu disebut Peramalan Deret Waktu Multi Variat.

Posting ini berfokus pada jenis metode peramalan tertentu yang disebut pemodelan ARIMA. (*Catatan: Jika Anda sudah mengetahui konsep ARIMA, lompat ke implementasi prakiraan ARIMA dalam tutorial video gratis (Peramalan dengan ARIMA dan Pengujian dan peningkatan hasil)

ARIMA, kependekan dari 'AutoRegressive Integrated Moving Average', adalah algoritme peramalan yang didasarkan pada gagasan bahwa informasi dalam nilai masa lalu dari deret waktu dapat digunakan untuk memprediksi nilai masa depan.

**2. Introduction to ARIMA Models**

Jawab :

Jadi apa sebenarnya model ARIMA itu?

ARIMA, kependekan dari 'Auto Regressive Integrated Moving Average' sebenarnya adalah kelas model yang 'menjelaskan' deret waktu tertentu berdasarkan nilai masa lalunya sendiri, yaitu lag-nya sendiri dan kesalahan perkiraan lag, sehingga persamaan dapat digunakan untuk meramalkan nilai masa depan. Ketahui lebih banyak tentang parameter ARIMA dan batasannya, dalam tutorial video gratis ini

Deret waktu 'non-musiman' apa pun yang menunjukkan pola dan bukan white noise acak dapat dimodelkan dengan model ARIMA.

Model ARIMA dicirikan oleh 3 suku: p, d, q

di mana,

p adalah orde suku AR

q adalah orde dari suku MA

d adalah jumlah diferensial yang diperlukan untuk membuat deret waktu stasioner

Jika deret waktu, memiliki pola musiman, maka Anda perlu menambahkan istilah musiman dan menjadi SARIMA, kependekan dari ‘ARIMA Musiman’. Lebih lanjut tentang itu setelah kita menyelesaikan ARIMA.

Jadi, apa sebenarnya yang dimaksud dengan 'urutan istilah AR'? Sebelum kita ke sana, mari kita lihat dulu istilah 'd'.

**3. What does the p, d and q in ARIMA model mean**

Jawab :

Langkah pertama untuk membangun model ARIMA adalah membuat deret waktu stasioner.

Mengapa?

Sebab, istilah ‘Auto Regressive’ dalam ARIMA berarti merupakan model regresi linier yang menggunakan lag-lagnya sendiri sebagai prediktor. Model regresi linier, seperti yang Anda tahu, bekerja paling baik ketika prediktor tidak berkorelasi dan independen satu sama lain.

Jadi bagaimana membuat seri stasioner?

Pendekatan yang paling umum adalah dengan membedakannya. Artinya, kurangi nilai sebelumnya dari nilai saat ini. Kadang-kadang, tergantung pada kompleksitas seri, lebih dari satu perbedaan mungkin diperlukan.

Oleh karena itu, nilai d adalah jumlah diferensial minimum yang diperlukan untuk membuat deret tersebut stasioner. Dan jika deret waktu sudah stasioner, maka d = 0.

Selanjutnya, apa istilah 'p' dan 'q'?

'p' adalah urutan istilah 'Auto Regressive' (AR). Hal ini mengacu pada jumlah lag dari Y yang akan digunakan sebagai prediktor. Dan 'q' adalah urutan istilah 'Moving Average' (MA). Ini mengacu pada jumlah kesalahan perkiraan tertinggal yang harus masuk ke Model ARIMA.

 

Implementasi langsung pada proyek nyata: Pelajari cara menerapkan ARIMA menggunakan beberapa strategi dan beberapa model deret waktu lainnya di Kursus Perkiraan Pengunjung Restoran saya

**4. What are AR and MA models**

Jawab :

Jadi apa itu model AR dan MA? apa rumus matematika yang sebenarnya untuk model AR dan MA?

Model Auto Regressive (hanya AR) murni adalah model di mana Yt hanya bergantung pada lag-nya sendiri. Artinya, Yt adalah fungsi dari 'keterlambatan Yt'.


di mana, Yt-1adalah lag1 dari deret tersebut, Beta adalah koefisien lag1 yang diestimasi oleh model dan alpha adalah suku intersep, yang juga diestimasi oleh model.

Video ini membahas tentang intuisi dan cara kerja model Auto Regressive. Dan bagaimana PACF dapat dimanfaatkan untuk membangun model AR.

Demikian pula model Rata-Rata Pergerakan murni (hanya MA) adalah model di mana Yt hanya bergantung pada kesalahan perkiraan yang tertinggal.


di mana istilah kesalahan adalah kesalahan model autoregressive dari masing-masing lag. Error Et dan E(t-1) merupakan error dari persamaan berikut :


Itu adalah model AR dan MA masing-masing.

Jadi seperti apa persamaan model ARIMA?

Model ARIMA adalah model di mana deret waktu dibedakan setidaknya sekali untuk membuatnya stasioner dan Anda menggabungkan istilah AR dan MA. Sehingga persamaannya menjadi:


Model ARIMA dengan kata-kata:

Prediksi Yt = Konstanta + Kombinasi linier Lag dari Y (hingga p lag) + Kombinasi Linier dari kesalahan prakiraan Lagged (hingga q lag)

Oleh karena itu, tujuannya adalah untuk mengidentifikasi nilai p, d dan q. Tapi bagaimana caranya?

Mari kita mulai dengan menemukan 'd'.

**5. How to find the order of differencing (d) in ARIMA model**

Jawab :

Tujuan dari differencing untuk membuat time series stasioner.

Tetapi Anda harus berhati-hati agar tidak terlalu membedakan seri. Karena, deret yang berdiferensiasi lebih mungkin masih stasioner, yang pada gilirannya akan mempengaruhi parameter model.

Lalu bagaimana cara menentukan orde differencing yang benar?

Urutan differencing yang benar adalah differencing minimum yang diperlukan untuk mendapatkan deret mendekati stasioner yang bergerak di sekitar mean yang ditentukan dan plot ACF mencapai nol dengan cukup cepat.

Jika autokorelasi positif untuk banyak lag (10 atau lebih), maka deret tersebut perlu didiferensiasi lebih lanjut. Di sisi lain, jika autokorelasi lag 1 itu sendiri terlalu negatif, maka deretnya mungkin over-difference.

Jika Anda tidak dapat benar-benar memutuskan antara dua orde pembedaan, maka pilihlah orde yang memberikan deviasi standar terkecil dalam deret berdiferensiasi.

Mari kita lihat bagaimana melakukannya dengan sebuah contoh.

Pertama, saya akan memeriksa apakah seri tersebut stasioner menggunakan tes Augmented Dickey Fuller (adfuller()), dari paket statsmodels.

Mengapa?

Karena, Anda hanya perlu melakukan differencing jika deret tersebut tidak stasioner. Jika tidak, tidak diperlukan pembedaan, yaitu d=0.

Hipotesis nol dari tes ADF adalah bahwa deret waktu tidak stasioner. Jadi, jika nilai p pengujian lebih kecil dari tingkat signifikansi (0,05) maka Anda menolak hipotesis nol dan menyimpulkan bahwa deret waktu memang stasioner.

Jadi, dalam kasus kita, jika P Value > 0,05 kita lanjutkan dengan mencari orde differencing.
"""

import pandas as pd
from statsmodels.tsa.stattools import adfuller
from numpy import log
df = pd.read_csv('https://raw.githubusercontent.com/selva86/datasets/master/wwwusage.csv', names=['value'], header=0)
result = adfuller(df.value.dropna())
print('ADF Statistic: %f' % result[0])
print('p-value: %f' % result[1])

"""Karena nilai P lebih besar dari tingkat signifikansi, mari kita bedakan deretnya dan lihat seperti apa plot autokorelasinya."""

import numpy as np, pandas as pd
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
import matplotlib.pyplot as plt
plt.rcParams.update({'figure.figsize':(9,7), 'figure.dpi':120})

# Import data
df = pd.read_csv('https://raw.githubusercontent.com/selva86/datasets/master/wwwusage.csv', names=['value'], header=0)

# Original Series
fig, axes = plt.subplots(3, 2, sharex=True)
axes[0, 0].plot(df.value); axes[0, 0].set_title('Original Series')
plot_acf(df.value, ax=axes[0, 1])

# 1st Differencing
axes[1, 0].plot(df.value.diff()); axes[1, 0].set_title('1st Order Differencing')
plot_acf(df.value.diff().dropna(), ax=axes[1, 1])

# 2nd Differencing
axes[2, 0].plot(df.value.diff().diff()); axes[2, 0].set_title('2nd Order Differencing')
plot_acf(df.value.diff().diff().dropna(), ax=axes[2, 1])

plt.show()

"""Untuk deret di atas, deret waktu mencapai stasioneritas dengan dua orde differencing. Tetapi saat melihat plot autokorelasi untuk diferensi ke-2, lag masuk ke zona negatif jauh dengan cukup cepat, yang menunjukkan, deret tersebut mungkin telah dibeda-bedakan secara berlebihan.

Jadi, untuk sementara saya akan memperbaiki urutan differencing menjadi 1 meskipun deretnya tidak stasioner sempurna (stasioneritas lemah).

**6. How to find the order of the AR term (p)**

Jawab :

Langkah selanjutnya adalah mengidentifikasi apakah model membutuhkan istilah AR. Anda dapat mengetahui jumlah istilah AR yang diperlukan dengan memeriksa plot Partial Autocorrelation (PACF).

Tapi apa itu PACF?

Autokorelasi parsial dapat dibayangkan sebagai korelasi antara deret dan lag-nya, setelah mengecualikan kontribusi dari lag perantara. Jadi, PACF semacam menyampaikan korelasi murni antara lag dan seri. Dengan begitu, kamu akan tahu apakah lag itu dibutuhkan dalam istilah AR atau tidak.

Jadi apa rumus untuk PACF secara matematis?

Autokorelasi parsial lag (k) suatu deret adalah koefisien lag tersebut dalam persamaan autoregresi Y.

Persamaan autoregresi
Artinya, misalkan, jika Y_t adalah deret arus dan Y_t-1 adalah lag 1 dari Y, maka autokorelasi parsial dari lag 3 (Y_t-3) adalah koefisien alpha dari Y_t-3 dalam persamaan di atas.

Bagus. Sekarang, bagaimana menemukan jumlah istilah AR?

Setiap autokorelasi dalam deret stasioner dapat diperbaiki dengan menambahkan istilah AR yang cukup. Jadi, kita awalnya mengambil urutan istilah AR sama dengan banyak lag yang melintasi batas signifikansi di plot PACF.
"""

# PACF plot of 1st differenced series
plt.rcParams.update({'figure.figsize':(9,3), 'figure.dpi':120})

fig, axes = plt.subplots(1, 2, sharex=True)
axes[0].plot(df.value.diff()); axes[0].set_title('1st Differencing')
axes[1].set(ylim=(0,5))
plot_pacf(df.value.diff().dropna(), ax=axes[1])

plt.show()

"""Anda dapat mengamati bahwa PACF lag 1 cukup signifikan karena jauh di atas garis signifikansi. Lag 2 ternyata signifikan juga, sedikit berhasil melewati batas signifikansi (wilayah biru). Tapi saya akan menjadi konservatif dan sementara memperbaiki p sebagai 1.

**7. How to find the order of the MA term (q)**

Jawab :

Sama seperti bagaimana kita melihat plot PACF untuk jumlah istilah AR, Anda dapat melihat plot ACF untuk jumlah istilah MA. Istilah MA secara teknis, kesalahan perkiraan tertinggal.

ACF memberitahu berapa banyak istilah MA yang diperlukan untuk menghilangkan autokorelasi apapun dalam deret stasioner.

Mari kita lihat plot autokorelasi dari deret yang berbeda.
"""

import pandas as pd
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
import matplotlib.pyplot as plt
plt.rcParams.update({'figure.figsize':(9,3), 'figure.dpi':120})

# Import data
df = pd.read_csv('https://raw.githubusercontent.com/selva86/datasets/master/austa.csv')

fig, axes = plt.subplots(1, 2, sharex=True)
axes[0].plot(df.value.diff()); axes[0].set_title('1st Differencing')
axes[1].set(ylim=(0,1.2))
plot_acf(df.value.diff().dropna(), ax=axes[1])

plt.show()

"""Beberapa lag jauh di atas garis signifikansi. Jadi, mari kita perbaiki q sebagai 2. Jika ragu, gunakan model yang lebih sederhana yang cukup menjelaskan Y.

**8. How to handle if a time series is slightly under or over differenced**

Jawab :

Mungkin saja seri Anda sedikit di bawah perbedaan, yang membedakannya sekali lagi membuatnya sedikit berbeda.

Bagaimana menangani kasus ini?

Jika seri Anda sedikit berbeda, biasanya menambahkan satu atau lebih istilah AR tambahan. Demikian juga, jika sedikit over-difference, coba tambahkan istilah MA tambahan.

**9. How to build the ARIMA Model**

Jawab :

Sekarang setelah Anda menentukan nilai p, d, dan q, Anda memiliki semua yang diperlukan agar sesuai dengan model ARIMA. Mari kita gunakan implementasi ARIMA() dalam paket statsmodels. (** Anda juga dapat melihat pelajaran video gratis tentang memperkirakan pengunjung restoran dengan ARIMA dan kemudian memeriksa cara menguji dan meningkatkan modelnya)
"""

from statsmodels.tsa.arima_model import ARIMA

# 1,1,2 ARIMA Model
model = ARIMA(df.value, order=(1,1,2))
model_fit = model.fit(disp=0)
print(model_fit.summary())

"""Ringkasan model mengungkapkan banyak informasi. Tabel di tengah adalah tabel koefisien di mana nilai di bawah 'coef' adalah bobot dari masing-masing suku.

Perhatikan di sini koefisien suku MA2 mendekati nol dan Nilai-P pada kolom ‘P>|z|’ sangat tidak signifikan. Idealnya harus kurang dari 0,05 untuk masing-masing X menjadi signifikan.

Jadi, mari kita membangun kembali model tanpa istilah MA2.
"""

# 1,1,1 ARIMA Model
model = ARIMA(df.value, order=(1,1,1))
model_fit = model.fit(disp=0)
print(model_fit.summary())

"""Model AIC telah berkurang, yang bagus. Nilai P suku AR1 dan MA1 telah meningkat dan sangat signifikan (<< 0,05).

Mari kita plot residual untuk memastikan tidak ada pola (yaitu, mencari mean dan varians konstan).
"""

# Plot residual errors
residuals = pd.DataFrame(model_fit.resid)
fig, ax = plt.subplots(1,2)
residuals.plot(title="Residuals", ax=ax[0])
residuals.plot(kind='kde', title='Density', ax=ax[1])
plt.show()

"""Kesalahan residual tampak baik-baik saja dengan rata-rata hampir nol dan varians seragam. Mari kita plot aktual terhadap nilai yang dipasang menggunakan plot_predict()."""

# Actual vs Fitted
model_fit.plot_predict(dynamic=False)
plt.show()

"""Saat Anda menyetel dynamic=False, nilai lag dalam sampel digunakan untuk prediksi.

Artinya, model dilatih sampai nilai sebelumnya untuk membuat prediksi berikutnya. Hal ini dapat membuat ramalan yang pas dan aktual terlihat bagus secara artifisial.

Jadi, kami tampaknya memiliki model ARIMA yang layak. Tapi apakah itu yang terbaik?

Tidak dapat mengatakan itu pada saat ini karena kami belum benar-benar memperkirakan ke masa depan dan membandingkan perkiraan dengan kinerja sebenarnya.

Jadi, validasi nyata yang Anda butuhkan sekarang adalah validasi silang Out-of-Time.

**10. How to do find the optimal ARIMA model manually using Out-of-Time Cross validation**

Jawab :

Dalam validasi silang Out-of-Time, Anda mengambil beberapa langkah mundur dalam waktu dan memperkirakan ke masa depan sebanyak langkah yang Anda ambil kembali. Kemudian Anda membandingkan perkiraan dengan yang sebenarnya.

Untuk melakukan validasi silang di luar waktu, Anda perlu membuat set data pelatihan dan pengujian dengan membagi deret waktu menjadi 2 bagian yang berdekatan dalam rasio sekitar 75:25 atau proporsi yang wajar berdasarkan frekuensi waktu deret.

Mengapa saya tidak mengambil sampel data pelatihan secara acak, Anda bertanya?

Itu karena urutan urutan deret waktu harus utuh agar dapat digunakan untuk peramalan.
"""

from statsmodels.tsa.stattools import acf

# Create Training and Test
train = df.value[:85]
test = df.value[85:]

"""Anda sekarang dapat membangun model ARIMA pada set data pelatihan, memperkirakan, dan memplotnya."""

# Build Model
# model = ARIMA(train, order=(3,2,1))  
model = ARIMA(train, order=(1, 1, 1))  
fitted = model.fit(disp=-1)  

# Forecast
fc, se, conf = fitted.forecast(15, alpha=0.05)  # 95% conf

# Make as pandas series
fc_series = pd.Series(fc, index=test.index)
lower_series = pd.Series(conf[:, 0], index=test.index)
upper_series = pd.Series(conf[:, 1], index=test.index)

# Plot
plt.figure(figsize=(12,5), dpi=100)
plt.plot(train, label='training')
plt.plot(test, label='actual')
plt.plot(fc_series, label='forecast')
plt.fill_between(lower_series.index, lower_series, upper_series, 
                 color='k', alpha=.15)
plt.title('Forecast vs Actuals')
plt.legend(loc='upper left', fontsize=8)
plt.show()

"""Dari grafik, model ARIMA(1,1,1) tampaknya memberikan ramalan yang benar secara terarah. Dan nilai yang diamati sebenarnya terletak dalam pita kepercayaan 95%. Itu tampaknya baik-baik saja.

Tetapi masing-masing perkiraan yang diprediksi secara konsisten di bawah yang sebenarnya. Itu berarti, dengan menambahkan konstanta kecil ke perkiraan kami, akurasinya pasti akan meningkat. Jadi, pasti ada ruang untuk perbaikan.

Jadi, yang akan saya lakukan adalah meningkatkan orde differencing menjadi dua, yaitu set d=2 dan secara iteratif meningkatkan p hingga 5 dan kemudian q hingga 5 untuk melihat model mana yang memberikan AIC paling sedikit dan juga mencari a grafik yang memberikan lebih dekat aktual dan prakiraan.

Saat melakukan ini, saya mengawasi nilai P dari istilah AR dan MA dalam ringkasan model. Mereka harus mendekati nol, idealnya, kurang dari 0,05.
"""

# Build Model
model = ARIMA(train, order=(3, 2, 1))  
fitted = model.fit(disp=-1)  
print(fitted.summary())

# Forecast
fc, se, conf = fitted.forecast(15, alpha=0.05)  # 95% conf

# Make as pandas series
fc_series = pd.Series(fc, index=test.index)
lower_series = pd.Series(conf[:, 0], index=test.index)
upper_series = pd.Series(conf[:, 1], index=test.index)

# Plot
plt.figure(figsize=(12,5), dpi=100)
plt.plot(train, label='training')
plt.plot(test, label='actual')
plt.plot(fc_series, label='forecast')
plt.fill_between(lower_series.index, lower_series, upper_series, 
                 color='k', alpha=.15)
plt.title('Forecast vs Actuals')
plt.legend(loc='upper left', fontsize=8)
plt.show()

"""AIC telah berkurang menjadi 440 dari 515. Bagus. Nilai-P dari suku-suku X kurang dari < 0,05, yang merupakan hal yang bagus.

Jadi secara keseluruhan itu jauh lebih baik.

Idealnya, Anda harus kembali beberapa titik dalam waktu, seperti, kembali 1, 2, 3 dan 4 kuartal dan melihat bagaimana kinerja prakiraan Anda di berbagai titik dalam setahun.

Inilah latihan latihan yang bagus: Cobalah untuk kembali ke 27, 30, 33, 36 titik data dan lihat bagaimana kinerja prakiraan. Kinerja perkiraan dapat dinilai menggunakan berbagai metrik akurasi yang dibahas selanjutnya.

**11. Accuracy Metrics for Time Series Forecast**

Jawab :

Metrik akurasi yang umum digunakan untuk menilai perkiraan adalah:

Mean Absolute Percentage Error (MAPE)
Rata-rata Kesalahan (ME)
Mean Absolute Error (MAE)
Rata-rata Persentase Kesalahan (MPE)
Root Mean Squared Error (RMSE)
Lag 1 Autokorelasi Kesalahan (ACF1)
Korelasi antara Aktual dan Prakiraan (corr)
Kesalahan Min-Maksimum (minmaks)
Biasanya, jika Anda membandingkan prakiraan dari dua seri yang berbeda, MAPE, Correlation, dan Min-Max Error dapat digunakan.

Mengapa tidak menggunakan metrik lainnya?

Karena hanya tiga di atas yang merupakan persentase kesalahan yang bervariasi antara 0 dan 1. Dengan begitu, Anda dapat menilai seberapa bagus ramalan terlepas dari skala rangkaian.

Metrik kesalahan lainnya adalah kuantitas. Artinya, RMSE 100 untuk seri yang rata-ratanya dalam 1000 lebih baik daripada RMSE 5 untuk seri dalam 10-an. Jadi, Anda tidak dapat benar-benar menggunakannya untuk membandingkan perkiraan dua deret waktu berskala berbeda.
"""

# Accuracy metrics
def forecast_accuracy(forecast, actual):
    mape = np.mean(np.abs(forecast - actual)/np.abs(actual))  # MAPE
    me = np.mean(forecast - actual)             # ME
    mae = np.mean(np.abs(forecast - actual))    # MAE
    mpe = np.mean((forecast - actual)/actual)   # MPE
    rmse = np.mean((forecast - actual)**2)**.5  # RMSE
    corr = np.corrcoef(forecast, actual)[0,1]   # corr
    mins = np.amin(np.hstack([forecast[:,None], 
                              actual[:,None]]), axis=1)
    maxs = np.amax(np.hstack([forecast[:,None], 
                              actual[:,None]]), axis=1)
    minmax = 1 - np.mean(mins/maxs)             # minmax
    acf1 = acf(fc-test)[1]                      # ACF1
    return({'mape':mape, 'me':me, 'mae': mae, 
            'mpe': mpe, 'rmse':rmse, 'acf1':acf1, 
            'corr':corr, 'minmax':minmax})

forecast_accuracy(fc, test.values)

#> {'mape': 0.02250131357314834,
#>  'me': 3.230783108990054,
#>  'mae': 4.548322194530069,
#>  'mpe': 0.016421001932706705,
#>  'rmse': 6.373238534601827,
#>  'acf1': 0.5105506325288692,
#>  'corr': 0.9674576513924394,
#>  'minmax': 0.02163154777672227}

"""Sekitar 2,2% MAPE menyiratkan model ini sekitar 97,8% akurat dalam memprediksi 15 pengamatan berikutnya.

Sekarang Anda tahu cara membuat model ARIMA secara manual.

Tetapi dalam situasi industri, Anda akan diberikan banyak rangkaian waktu untuk diramalkan dan latihan peramalan diulang secara teratur.

Sehingga diperlukan suatu cara untuk mengotomatisasi proses pemilihan model terbaik.

**12. How to do Auto Arima Forecast in Python**

Jawab :

Seperti fungsi auto.arima() populer R, paket pmdarima menyediakan auto_arima() dengan fungsi serupa.

auto_arima() menggunakan pendekatan bertahap untuk mencari beberapa kombinasi parameter p,d,q dan memilih model terbaik yang memiliki AIC paling sedikit.
"""

pip install pmdarima

from statsmodels.tsa.arima_model import ARIMA
import pmdarima as pm
import pandas as pd

df = pd.read_csv('https://raw.githubusercontent.com/selva86/datasets/master/wwwusage.csv', names=['value'], header=0)

model = pm.auto_arima(df.value, start_p=1, start_q=1,
                      test='adf',       # use adftest to find optimal 'd'
                      max_p=3, max_q=3, # maximum p and q
                      m=1,              # frequency of series
                      d=None,           # let model determine 'd'
                      seasonal=False,   # No Seasonality
                      start_P=0, 
                      D=0, 
                      trace=True,
                      error_action='ignore',  
                      suppress_warnings=True, 
                      stepwise=True)

print(model.summary())

"""**13. How to interpret the residual plots in ARIMA model**

Jawab :

Mari kita tinjau plot residual menggunakan stepwise_fit.
"""

import matplotlib.pyplot as plt
model.plot_diagnostics(figsize=(7,5))
plt.show()

"""Jadi bagaimana menafsirkan diagnostik plot?

Kiri atas: Kesalahan residual tampaknya berfluktuasi di sekitar rata-rata nol dan memiliki varian yang seragam.

Kanan Atas: Plot kepadatan menunjukkan distribusi normal dengan rata-rata nol.

Kiri bawah: Semua titik harus tepat sejajar dengan garis merah. Setiap penyimpangan yang signifikan akan menyiratkan distribusi miring.

Kanan Bawah: Correlogram, alias, plot ACF menunjukkan kesalahan residual tidak autokorelasi. Setiap autokorelasi akan menyiratkan bahwa ada beberapa pola dalam kesalahan residual yang tidak dijelaskan dalam model. Jadi, Anda perlu mencari lebih banyak X (prediktor) pada model.

Secara keseluruhan, tampaknya cocok. Mari kita prediksi.
"""

import numpy as np, pandas as pd
# Forecast
n_periods = 24
fc, confint = model.predict(n_periods=n_periods, return_conf_int=True)
index_of_fc = np.arange(len(df.value), len(df.value)+n_periods)

# make series for plotting purpose
fc_series = pd.Series(fc, index=index_of_fc)
lower_series = pd.Series(confint[:, 0], index=index_of_fc)
upper_series = pd.Series(confint[:, 1], index=index_of_fc)

# Plot
plt.plot(df.value)
plt.plot(fc_series, color='darkgreen')
plt.fill_between(lower_series.index, 
                 lower_series, 
                 upper_series, 
                 color='k', alpha=.15)

plt.title("Final Forecast of WWW Usage")
plt.show()

"""**14. How to automatically build SARIMA model in python**

Jawab :

Masalah dengan model ARIMA biasa adalah tidak mendukung musiman.

Jika deret waktu Anda telah menentukan musim, maka, pilih SARIMA yang menggunakan perbedaan musiman.

Diferensiasi musiman mirip dengan diferensiasi reguler, tetapi, alih-alih mengurangkan suku berurutan, Anda mengurangi nilai dari musim sebelumnya.

Jadi, model akan direpresentasikan sebagai SARIMA(p,d,q)x(P,D,Q), di mana, P, D dan Q adalah SAR, urutan perbedaan musiman dan suku SMA masing-masing dan 'x' adalah frekuensi dari deret waktu.

Jika model Anda memiliki pola musiman yang terdefinisi dengan baik, maka terapkan D=1 untuk frekuensi 'x' yang diberikan.

Berikut beberapa saran praktis dalam membangun model SARIMA:

Sebagai aturan umum, atur parameter model sedemikian rupa sehingga D tidak pernah melebihi satu. Dan perbedaan total 'd + D' tidak pernah melebihi 2. Cobalah untuk hanya menggunakan istilah SAR atau SMA jika model Anda memiliki komponen musiman.

Mari kita buat model SARIMA di 'a10' – kumpulan data penjualan obat.
"""

# Import
data = pd.read_csv('https://raw.githubusercontent.com/selva86/datasets/master/a10.csv', parse_dates=['date'], index_col='date')

# Plot
fig, axes = plt.subplots(2, 1, figsize=(10,5), dpi=100, sharex=True)

# Usual Differencing
axes[0].plot(data[:], label='Original Series')
axes[0].plot(data[:].diff(1), label='Usual Differencing')
axes[0].set_title('Usual Differencing')
axes[0].legend(loc='upper left', fontsize=10)


# Seasinal Dei
axes[1].plot(data[:], label='Original Series')
axes[1].plot(data[:].diff(12), label='Seasonal Differencing', color='green')
axes[1].set_title('Seasonal Differencing')
plt.legend(loc='upper left', fontsize=10)
plt.suptitle('a10 - Drug Sales', fontsize=16)
plt.show()

"""Seperti yang dapat Anda lihat dengan jelas, lonjakan musiman tetap utuh setelah menerapkan pembedaan biasa (lag 1). Padahal, itu diperbaiki setelah perbedaan musiman.

Mari kita membangun model SARIMA menggunakan auto_arima() pmdarima. Untuk melakukan itu, Anda perlu mengatur musiman=Benar, mengatur frekuensi m=12 untuk seri bulan bijaksana dan menegakkan D=1.
"""

# !pip3 install pyramid-arima
import pmdarima as pm

# Seasonal - fit stepwise auto-ARIMA
smodel = pm.auto_arima(data, start_p=1, start_q=1,
                         test='adf',
                         max_p=3, max_q=3, m=12,
                         start_P=0, seasonal=True,
                         d=None, D=1, trace=True,
                         error_action='ignore',  
                         suppress_warnings=True, 
                         stepwise=True)

smodel.summary()

"""Model telah mengestimasi AIC dan nilai P dari koefisien terlihat signifikan. Mari kita lihat plot diagnostik residual.

Model terbaik SARIMAX(3, 0, 0)x(0, 1, 1, 12) memiliki AIC sebesar 528,6 dan Nilai P signifikan.

Mari kita prediksi untuk 24 bulan ke depan.
"""

# Forecast
n_periods = 24
fitted, confint = smodel.predict(n_periods=n_periods, return_conf_int=True)
index_of_fc = pd.date_range(data.index[-1], periods = n_periods, freq='MS')

# make series for plotting purpose
fitted_series = pd.Series(fitted, index=index_of_fc)
lower_series = pd.Series(confint[:, 0], index=index_of_fc)
upper_series = pd.Series(confint[:, 1], index=index_of_fc)

# Plot
plt.plot(data)
plt.plot(fitted_series, color='darkgreen')
plt.fill_between(lower_series.index, 
                 lower_series, 
                 upper_series, 
                 color='k', alpha=.15)

plt.title("SARIMA - Final Forecast of a10 - Drug Sales")
plt.show()

"""Di sana Anda memiliki ramalan bagus yang menangkap pola permintaan musiman yang diharapkan.

**15. How to build SARIMAX Model with exogenous variable**

Jawab :

The SARIMA model we built is good. I would stop here typically.

But for the sake of completeness, let’s try and force an external predictor, also called, ‘exogenous variable’ into the model. This model is called the SARIMAX model.

The only requirement to use an exogenous variable is you need to know the value of the variable during the forecast period as well.

For the sake of demonstration, I am going to use the seasonal index from the classical seasonal decomposition on the latest 36 months of data.

Why the seasonal index? Isn’t SARIMA already modeling the seasonality, you ask?

You are correct.

But also, I want to see how the model looks if we force the recent seasonality pattern into the training and forecast.

Secondly, this is a good variable for demo purpose. So you can use this as a template and plug in any of your variables into the code. The seasonal index is a good exogenous variable because it repeats every frequency cycle, 12 months in this case.

So, you will always know what values the seasonal index will hold for the future forecasts.
"""

# Import Data
data = pd.read_csv('https://raw.githubusercontent.com/selva86/datasets/master/a10.csv', parse_dates=['date'], index_col='date')

"""Mari kita hitung indeks musiman sehingga dapat dipaksakan sebagai prediktor (eksogen) pada model SARIMAX."""

# Compute Seasonal Index
from statsmodels.tsa.seasonal import seasonal_decompose
from dateutil.parser import parse

# multiplicative seasonal component
result_mul = seasonal_decompose(data['value'][-36:],   # 3 years
                                model='multiplicative', 
                                extrapolate_trend='freq')

seasonal_index = result_mul.seasonal[-12:].to_frame()
seasonal_index['month'] = pd.to_datetime(seasonal_index.index).month

# merge with the base data
data['month'] = data.index.month
df = pd.merge(data, seasonal_index, how='left', on='month')
df.columns = ['value', 'month', 'seasonal_index']
df.index = data.index  # reassign the index.

"""Variabel eksogen (indeks musiman) sudah siap. Mari kita buat model SARIMAX."""

import pmdarima as pm

# SARIMAX Model
sxmodel = pm.auto_arima(df[['value']], exogenous=df[['seasonal_index']],
                           start_p=1, start_q=1,
                           test='adf',
                           max_p=3, max_q=3, m=12,
                           start_P=0, seasonal=True,
                           d=None, D=1, trace=True,
                           error_action='ignore',  
                           suppress_warnings=True, 
                           stepwise=True)

sxmodel.summary()

"""Jadi, kami memiliki model dengan istilah eksogen. Tetapi koefisiennya sangat kecil untuk x1, sehingga kontribusi dari variabel tersebut akan diabaikan. Mari kita memperkirakannya.

Kami telah secara efektif memaksakan efek musiman terbaru dari 3 tahun terakhir ke dalam model, bukan keseluruhan sejarah.

Baiklah mari kita ramalkan dalam 24 bulan ke depan. Untuk ini, Anda memerlukan nilai indeks musiman selama 24 bulan ke depan.

**16. Practice Exercises**

Jawab :

Dalam kumpulan data AirPassengers, kembali ke waktu 12 bulan dan buat perkiraan SARIMA untuk 12 bulan ke depan.

Apakah seri stasioner? Jika tidak, pembedaan macam apa yang diperlukan?
Apa urutan model terbaik Anda?
Apa AIC model Anda?
Apa yang dicapai MAPE dalam validasi silang OOT?
Berapa urutan model terbaik yang diprediksi oleh metode auto_arima()?

**17. Conclusion**

Jawab :

Selamat jika Anda mencapai titik ini. Beri diri Anda pelukan BESAR jika Anda mampu menyelesaikan latihan latihan.

Saya sangat berharap Anda menemukan ini berguna?

Kami telah membahas banyak konsep mulai dari peramalan yang paling dasar, AR, MA, ARIMA, SARIMA dan akhirnya model SARIMA. Jika ada pertanyaan silahkan tulis di kolom komentar. Sementara itu, saya akan mengerjakan artikel berikutnya.
"""